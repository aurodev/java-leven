#version 430 core

layout (local_size_x = 9, local_size_y = 8, local_size_z = 8) in;

layout (std430, binding = 0) buffer indices {
    int j[];
} bit_reversed;

layout (std430, binding = 1) buffer layoutName {
    int it[];
} Perm;

uniform int N;  //primitiveModCount
/*
vec3 Grad3[] = {
    vec3(1,1,0), vec3(-1,1,0), vec3(1,-1,0), vec3(-1,-1,0),
    vec3(1,0,1), vec3(-1,0,1), vec3(1,0,-1), vec3(-1,0,-1),
    vec3(0,1,1), vec3(0,-1,1), vec3(0,1,-1), vec3(0,-1,-1)
};

float Box(vec3 worldPosition, vec3 origin, vec3 halfDimensions)
{
    vec3 local_pos = worldPosition - origin;
    vec3 pos = local_pos;

    vec3 d = vec3(abs(pos.x), abs(pos.y), abs(pos.z)) - halfDimensions;
    float m = max(d.x, max(d.y, d.z));
    return min(m, length(max(d, vec3(0, 0, 0))));
}

float Sphere(vec3 worldPosition, vec3 origin, float radius)
{
    return length(worldPosition - origin) - radius;
}

float Cylinder(vec3 worldPosition, vec3 origin, vec3 size)
{
    vec3 p = worldPosition - origin;

    if (Box(worldPosition, origin, size) > 0.0f)
    return 1;

    float sqr_dist = (p.x * p.x + p.z * p.z);
    float sqr_rad = size.x * size.x;
    return sqr_dist - sqr_rad;
}

float Torus(vec3 worldPosition, vec3 origin)
{
    vec3 local_pos = worldPosition - origin;
    float xt = local_pos.x;
    float yt = local_pos.y;
    float zt = local_pos.z;
    float _radius = 10.0f;
    float _radius2 = 2.33f;

    float x = xt;
    float y = yt;
    float z = zt;

    float x2 = sqrt(x * x + z * z) - _radius / 2.0f;
    float d = x2 * x2 + y * y - _radius2 * _radius2;

    return d;
}

float Perlin(float x, float y)
{
    int i = x > 0 ? int(x) : int(x) - 1;
    int j = y > 0 ? int(y) : int(y) - 1;

    x = x - i;
    y = y - j;

    i = i & 255;
    j = j & 255;

int gll = Perm.it[i + Perm.it[j]] % 12;
int glh = Perm.it[i + Perm.it[j + 1]] % 12;
int ghl = Perm.it[i + 1 + Perm.it[j]] % 12;
int ghh = Perm.it[i + 1 + Perm.it[j + 1]] % 12;

float nll = (Grad3[gll].x * x) + (Grad3[gll].y * y);
float nlh = (Grad3[glh].x * x) + (Grad3[glh].y * (y - 1));
float nhl = (Grad3[ghl].x * (x - 1)) + (Grad3[ghl].y * y);
float nhh = (Grad3[ghh].x * (x - 1)) + (Grad3[ghh].y * (y - 1));

float u = float(x * x * x * (x * (x * 6 - 15) + 10));
float v = float(y * y * y * (y * (y * 6 - 15) + 10));

//float nyl = Mathf.Lerp(nll, nhl, u);
float nyl = (1-u)*nll + u*nhl;
//float nyh = Mathf.Lerp(nlh, nhh, u);
float nyh = (1-u)*nlh + u*nhh;

//float nxy = Mathf.Lerp(nyl, nyh, v);
float nxy = (1-v)*nyl + v*nyh;

return nxy;
}

float Vec3Dot(vec3 a, vec3 b)
{
    float res = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
    return res;
}

float lerp(float a, float b, float t)
{
    return (1 - t) * a + t * b;
}

float Perlin(float x, float y, float z)
{
    int X = x > 0 ? int(x) : int(x) - 1;
int Y = y > 0 ? int(y) : int(y) - 1;
int Z = z > 0 ? int(z) : int(z) - 1;

x = x - X;
y = y - Y;
z = z - Z;

X = X & 255;
Y = Y & 255;
Z = Z & 255;

int gi000 = Perm.it[X + Perm.it[Y + Perm.it[Z]]] % 12;
int gi001 = Perm.it[X + Perm.it[Y + Perm.it[Z + 1]]] % 12;
int gi010 = Perm.it[X + Perm.it[Y + 1 + Perm.it[Z]]] % 12;
int gi011 = Perm.it[X + Perm.it[Y + 1 + Perm.it[Z + 1]]] % 12;
int gi100 = Perm.it[X + 1 + Perm.it[Y + Perm.it[Z]]] % 12;
int gi101 = Perm.it[X + 1 + Perm.it[Y + Perm.it[Z + 1]]] % 12;
int gi110 = Perm.it[X + 1 + Perm.it[Y + 1 + Perm.it[Z]]] % 12;
int gi111 = Perm.it[X + 1 + Perm.it[Y + 1 + Perm.it[Z + 1]]] % 12;

float n000 = Vec3Dot(Grad3[gi000], vec3(x, y, z));
float n100 = Vec3Dot(Grad3[gi100], vec3(x - 1, y, z));
float n010 = Vec3Dot(Grad3[gi010], vec3(x, y - 1, z));
float n110 = Vec3Dot(Grad3[gi110], vec3(x - 1, y - 1, z));
float n001 = Vec3Dot(Grad3[gi001], vec3(x, y, z - 1));
float n101 = Vec3Dot(Grad3[gi101], vec3(x - 1, y, z - 1));
float n011 = Vec3Dot(Grad3[gi011], vec3(x, y - 1, z - 1));
float n111 = Vec3Dot(Grad3[gi111], vec3(x - 1, y - 1, z - 1));

float u = float(x * x * x * (x * (x * 6 - 15) + 10));
float v = float(y * y * y * (y * (y * 6 - 15) + 10));
float w = float(z * z * z * (z * (z * 6 - 15) + 10));

float nx00 = lerp(n000, n100, u);
float nx01 = lerp(n001, n101, u);
float nx10 = lerp(n010, n110, u);
float nx11 = lerp(n011, n111, u);

float nxy0 = lerp(nx00, nx10, v);
float nxy1 = lerp(nx01, nx11, v);

float nxyz = lerp(nxy0, nxy1, w);

return nxyz;
}

float FractalNoise(int octaves, float frequency, float lacunarity, float persistence, vec2 position)
{
    float SCALE = 1.0f / 128.0f;
    vec2 p = position * SCALE;
    float nois = 0.0f;

    float amplitude = 1.0f;
    p *= frequency;

    for (int i = 0; i < octaves; i++)
    {
        nois += Perlin(p.x, p.y) * amplitude;
        p *= lacunarity;
        amplitude *= persistence;
    }

    return 0.5f + (0.5f * nois);
}

float FractalNoise(int octaves, float frequency, float lacunarity, float persistence, vec3 position)
{
    float SCALE = 1.0f / 128.0f;
    vec3 p = position * SCALE;
    float nois = 0.0f;

    float amplitude = 1.0f;
    p *= frequency;

    for (int i = 0; i < octaves; i++)
    {
        nois += Perlin(p.x, p.y, p.z) * amplitude;
        p *= lacunarity;
        amplitude *= persistence;
    }

    return nois;
}

float FractalNoise(float frequency, float lacunarity, float persistence, vec3 position)
{
    float SCALE = 1.0f / 128.0f;
    vec3 p = position * SCALE;
    float nois = 0.0f;

    float amplitude = 1.0f;
    p *= frequency;

    nois += Perlin(p.x, p.y, p.z) * amplitude;
    p *= lacunarity;
    amplitude *= persistence;

    return nois;
}

float CalculateNoiseValue(vec3 pos, float scale)
{
    return FractalNoise(4, 0.5343f, 2.2324f, 0.68324f, pos * scale);
}

float CLerp(float a, float b, float t)
{
    return (1 - t) * a + t * b;
}

float Density_Func(vec3 worldPosition)
{
    float worldRadius = 200.0f;
    vec3 world = worldPosition - vec3(0, -worldRadius, 0);
    float worldDist = -worldRadius + length(world);

    float flatlandNoiseScale = 1.0f;
    float flatlandLerpAmount = 0.07f;
    float flatlandYPercent = 1.2f;

    float rockyNoiseScale = 1.5f;
    float rockyLerpAmount = 0.05f;
    float rockyYPercent = 0.7f;

    float maxMountainMixLerpAmount = 0.075f;
    float minMountainMixLerpAmount = 1.0f;

    float mountainBlend = 0.0f;
    float rockyBlend = 1.0f;

    //mountainBlend = saturate(abs(FractalNoise(0.5343f, 2.2324f, 0.68324f, world * 0.11f)) * 4.0f);
    mountainBlend = clamp(abs(FractalNoise(0.5343f, 2.2324f, 0.68324f, world * 0.11f)) * 4.0f, 0.0, 1.0);

    float mountain = CalculateNoiseValue(world, 0.07f);

    float blob = CalculateNoiseValue(world, flatlandNoiseScale + ((rockyNoiseScale - flatlandNoiseScale) * rockyBlend));
    blob = CLerp(blob, (worldDist) * (flatlandYPercent + ((rockyYPercent - flatlandYPercent) * rockyBlend)),
    flatlandLerpAmount + ((rockyLerpAmount - flatlandLerpAmount) * rockyBlend));

    float result = ((worldDist) / worldRadius) + CLerp(mountain, blob, minMountainMixLerpAmount + ((maxMountainMixLerpAmount - minMountainMixLerpAmount) * mountainBlend));

    for (int i = 0; i < N; i++)
    {
        float primitive = 0;
        bool primChosen = primitiveMods[i].type == 0 || primitiveMods[i].type == 1 || primitiveMods[i].type == 2;

        if (primChosen)
        {
            if (primitiveMods[i].type == 0)
            {
                primitive = Box(worldPosition, primitiveMods[i].position, primitiveMods[i].size);
            }
            else if (primitiveMods[i].type == 1)
            {
                primitive = Sphere(worldPosition, primitiveMods[i].position, primitiveMods[i].size.x);
            }
            else if (primitiveMods[i].type == 2)
            {
                primitive = Cylinder(worldPosition, primitiveMods[i].position, primitiveMods[i].size);
            }

            if (primitiveMods[i].csg == 0)
            {
                result = max(-primitive, result);
            }
            else
            {
                result = min(primitive, result);
            }
        }
    }

    return result;
}
*/
void main(void)
{
    //	uint x = gl_GlobalInvocationID.x;
    //	uint y = gl_GlobalInvocationID.y;
    //	uint z = gl_GlobalInvocationID.z;
    //	const uint index = x + (y * 64) + (z * 64 * 64);

    uint index = gl_GlobalInvocationID.x + 9 * (gl_GlobalInvocationID.y + 8 * gl_GlobalInvocationID.z);

    int t = bit_reversed.j[index];
    bit_reversed.j[index] = t + N;

    //Perm.it[gl_GlobalInvocationID.x] = 6;
    Perm.it[index] = 6;
}

